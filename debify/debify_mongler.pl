#!/usr/bin/env perl
package debify::mongler;

use strict;
use warnings;

use Cwd            ();
use File::Basename ();
use File::Slurper  ();

exit run(@ARGV) unless caller;

# This script exists to keep the %install and %files list
# N*Sync because debifain't no lie baby bye bye bye
sub run {
    my @args = @_;

    my $install_boilerplate = <<'BOIL';
#!/bin/bash

# Fix buildroot for Debian builds - it should be debian/tmp
# The vars.sh file sets it to /usr/src/packages/BUILD which is wrong
source debian/vars.sh
export buildroot="debian/tmp"

BOIL

    my $repo_dir  = Cwd::abs_path( File::Basename::dirname(__FILE__) . '/../' );
    my $spec2open = "$repo_dir/SPECS/cpanel-csf.spec";
    open( my $fh, "<", $spec2open ) or die "Can't open '$spec2open': $!";
    my @spec_lines = <$fh>;
    close $fh;

    _write_override_dh_auto_install( $repo_dir, $install_boilerplate, \@spec_lines );
    _write_deb_install_file( $repo_dir, $spec2open, \@spec_lines );

    return 0;
}

sub _write_override_dh_auto_install {
    my ( $repo_dir, $boilerplate, $spec_lines ) = @_;

    my $file_contents = "$boilerplate\n";
    my $in_install    = 0;
    for my $line ( @{$spec_lines} ) {
        if ( !$in_install ) {
            $in_install = index( $line, '%install' ) == 0;
            next;
        }
        $in_install = index( $line, '# END INSTALL' ) == -1;
        last if !$in_install;
        $file_contents .= $line;
    }

    # Variable brain transplant: %{buildroot} -> $buildroot
    $file_contents =~ s/%\{buildroot\}/\$buildroot/g;

    my $file = "$repo_dir/debify/debian/override_dh_auto_install.sh";
    File::Slurper::write_text( $file, $file_contents );
    system( qw{chmod +x}, $file ) and die "Can't chmod +x '$file', script exited $?";

    return;
}

sub _write_deb_install_file {
    my ( $repo_dir, $spec2open, $spec_lines ) = @_;

    # Derive package name from the spec Name: field
    my ($pkg_name) = map { /^Name:\s+(\S+)/ ? ($1) : () } @{$spec_lines};
    die "Could not determine package Name from $spec2open\n" if !$pkg_name;

    my $spec_basename = File::Basename::basename($spec2open);
    my $content       = "# Autogenerated by debify/debify_mongler.pl from SPECS/$spec_basename\n";
    $content .= "# Do not edit by hand; update the %files section in the spec instead.\n";

    my $in_files = 0;
    for my $line ( @{$spec_lines} ) {
        chomp( my $l = $line );

        if ( !$in_files ) {
            $in_files = ( $l =~ /^%files\s*$/ );
            next;
        }

        # %changelog (or any new top-level section) ends %files
        last if $l =~ /^%(?:changelog|prep|build|install|clean|pre|post|preun|postun|package|description)\b/;

        # Skip blank lines and comments
        next if $l =~ /^\s*$/ || $l =~ /^\s*#/;

        # %defattr and %dir are RPM-only ownership directives; skip them
        next if $l =~ /^%defattr\b/;
        next if $l =~ /^%dir\b/;

        # Strip file-list directives to expose the bare path
        $l =~ s/^%config\(noreplace\)\s*//;
        $l =~ s/^%config\s*//;
        $l =~ s/^%attr\([^)]*\)\s*//;
        $l =~ s/^%doc\s*//;
        $l =~ s/^%ghost\s*//;
        $l =~ s/^%verify\([^)]*\)\s*//;
        $l =~ s/^%license\s*//;

        # Skip any remaining unrecognised directives
        next if $l =~ /^%/;

        my $path = $l;

        # Destination dir: strip trailing /* for globs, otherwise dirname of path
        my $dest;
        if ( $path =~ m{^(.*)/\*} ) {
            $dest = $1;
        }
        else {
            ( $dest = $path ) =~ s{/[^/]+$}{};
        }

        $content .= "debian/tmp$path $dest\n";
    }

    my $file = "$repo_dir/debify/debian/$pkg_name.install";
    File::Slurper::write_text( $file, $content );

    return;
}

1;
